import { useState, useCallback } from "react";
import {
  useAccount,
  useWaitForTransactionReceipt,
  useSendTransaction,
} from "wagmi";
import {
  getFlyTransaction,
  executeFlySwap,
  getFlyQuote,
  type FlyQuoteRequest,
} from "@/lib/api/fly-api";
import type { SwapQuote } from "@/types";

interface UseSwapExecutionProps {
  quote: SwapQuote | null;
  quoteRequest?: FlyQuoteRequest | null;
  gasless: boolean;
  onSuccess?: () => void;
}

export function useSwapExecution({
  quote,
  quoteRequest,
  gasless,
  onSuccess,
}: UseSwapExecutionProps) {
  const { address } = useAccount();
  const [isExecuting, setIsExecuting] = useState(false);
  const [executionError, setExecutionError] = useState<string | null>(null);
  const [swapId, setSwapId] = useState<string | null>(null);

  const {
    sendTransaction,
    isPending: isTransactionPending,
    data: txHash,
  } = useSendTransaction();
  const { isLoading: isTransactionConfirming } = useWaitForTransactionReceipt({
    hash: txHash,
  });

  const executeSwap = useCallback(async () => {
    if (!address) {
      setExecutionError("Missing wallet address");
      return;
    }

    setIsExecuting(true);
    setExecutionError(null);

    try {
      // Ensure we have a fresh quote id in case the previous expired
      let effectiveQuote: any = quote;
      if (!effectiveQuote && quoteRequest) {
        effectiveQuote = await getFlyQuote(quoteRequest);
      }
      if (!effectiveQuote) {
        throw new Error("No quote available");
      }

      if (gasless) {
        // Execute gasless swap through Fly protocol
        console.log("Executing gasless swap...");

        // For gasless swaps, we need to sign permit and swap signatures
        // This is a simplified implementation - in reality, you'd need to:
        // 1. Sign permit for token approval
        // 2. Sign swap transaction
        // 3. Send signatures to Fly protocol for execution

        const swapResult = await executeFlySwap({
          networkName: "ethereum", // This should be derived from the quote
          quoteId: effectiveQuote.id,
          swapSignature: "0x...", // Would be generated by signing
          permitSignature: "0x...", // Would be generated by signing
          permitDeadline: Math.floor(Date.now() / 1000) + 3600, // 1 hour
        });

        setSwapId(swapResult.id);
        console.log("Gasless swap initiated:", swapResult);
      } else {
        // Execute swap with user's own gas
        console.log("Executing self-paid swap...");

        // Always use /aggregator/transaction. If it fails due to stale id, refresh once.
        let transactionData;
        try {
          transactionData = await getFlyTransaction(effectiveQuote.id);
        } catch (err) {
          if (quoteRequest) {
            const refreshed = await getFlyQuote(quoteRequest);
            transactionData = await getFlyTransaction(refreshed.id);
            effectiveQuote = refreshed;
          } else {
            throw err;
          }
        }

        // Send raw transaction (no ABI) with EIP-1559 support
        sendTransaction({
          to: transactionData.to as `0x${string}`,
          data: transactionData.data as `0x${string}`,
          value: transactionData.value
            ? BigInt(transactionData.value)
            : undefined,
          chainId: transactionData.chainId
            ? Number(transactionData.chainId)
            : undefined,
          gas: transactionData.gasLimit
            ? BigInt(transactionData.gasLimit)
            : undefined,
          // Prefer EIP-1559 fields when provided
          maxFeePerGas: transactionData.maxFeePerGas
            ? BigInt(transactionData.maxFeePerGas)
            : undefined,
          maxPriorityFeePerGas: transactionData.maxPriorityFeePerGas
            ? BigInt(transactionData.maxPriorityFeePerGas)
            : undefined,
          // Fallback to legacy gasPrice
          gasPrice:
            !transactionData.maxFeePerGas && transactionData.gasPrice
              ? BigInt(transactionData.gasPrice)
              : undefined,
        });
      }

      onSuccess?.();
    } catch (error: any) {
      console.error("Swap execution failed:", error);
      const apiMsg =
        typeof error?.message === "string"
          ? error.message
          : "Swap execution failed";
      setExecutionError(apiMsg);
    } finally {
      setIsExecuting(false);
    }
  }, [quote, quoteRequest, address, gasless, sendTransaction, onSuccess]);

  const isLoading =
    isExecuting || isTransactionPending || isTransactionConfirming;

  return {
    executeSwap,
    isLoading,
    isExecuting,
    isTransactionPending,
    isTransactionConfirming,
    executionError,
    swapId,
  };
}
